#include "stdafx.h"
#include <iostream> //<- для cout cin
//#include <windows.h>
#include <string>
#include <fstream> //<- для работы с файлами


using namespace System;using namespace std;
int Parse(char R[], int razmer){
	int *allcifrs = new int[20];   // <- массив всех чисел в формуле
	char *Znaki = new char[20];   // <- массив всех операций в формуле (кроме скобок)
	int *Prioritet = new int[20];   // <- массив всех приоритетов действий (типа умножения делаются первыми)
	int q=0, C=0, Z=0, sk=0, mnI=1;   // <- дополнительные переменные (для распарсивания чисел, количество чисел, количество операций, степень скобки и мнимая единица)
	for(int i=0; i<razmer; i++){   // <- для начала проверим правильность расстановки скобок (чтоб колличество открывающихся было равно количеству закрывающихся, и чтоб закрывающаяся не шла впереди)
		if(R[i]=='(') q++;   // <- для этого каждая открывающая скобка увеличивает переменную на 1...
		if(R[i]==')') q--;   // <- ...а каждая закрывающая уменьшаяет на 1.
		if(q<0)break;   // <- в минус переменная может уйти только в случае, если закрывающая пошла впереди открывающей скобки, что неверно и дальше идти нет смысла
	}
	if(q!=0){   // <- в конце всей проверки наша переменная долшна стать равна 0 (одинаковое количество раз увеличивалась на 1 и уменьшалась)
		if(q>0){ cout<<"В формуле есть незакрытая скобка"<<endl; }    // <- определяем тип ошибки
		else{ cout<<"В формуле есть закрывающая скобка (без открывающей)"<<endl; }   // <- 
		system("pause");
		return 0;   // <- и прерываем выполнение функции
	}
   // <- если функция дошла до сюда - значит переменная осталась на 0 (кстати, можно использовать любую переменную)
	for(int i=0; i<(razmer+1); i++){   // <- начинаем парс чисел
		if(((int)(R[i])-48)>=0 && ((int)(R[i])-48)<=9 && i<razmer){   // <- если распарсенный символ является числом...
			q=q*10+((int)(R[i])-48);   // <- ...прибавляем его к переменной для парса. Накапливаем результат (типа '3','5'  0*10+3 потом 3*10+5 и получим из '3','5' 35. ну тут изи)
		}else{   // <- иначе...
			if(((int)(R[i-1])-48)>=0 && ((int)(R[i-1])-48)<=9 && i>0){ allcifrs[C]=q*mnI; C++;}   // <- ...проверяем, если сейчас знак операции, А ПРЕДЫДУЩИЙ БЫЛ ЧИСЛОМ (для того, чтоб в случае 5*(-1) где подрят три знака '*', '(' и '-' одна операция не повторилась три раза) - то накопленный результат сохраняем в массив "все числа"
			q=0;   // <- накопленный результат обнуляем
			switch(R[i]){   // <- так же если это не число, мы проверям, что это за операция и сохраняем знак операции в массив "Знаки", так же расставляем приоритеты знаков.
				case '+' : Znaki[Z]=R[i]; Prioritet[Z]=1+sk; mnI=1; Z++; break;   // <- операция - и + имеют приоритет 1 + степень скобки (в случае, если они находятся в скобках, степень в разы выше)
				case '-' : if( (R[i-1]!='(' || ((int)(R[i-1])-48)>=0 && ((int)(R[i-1])-48)<=9) && i>0 ){   // <- с минусом не так просто. Нужно выяснить, является ли он знаком операции минус, или частью отрицательного числа. для этого выясняем, не стоит ли он после открывающейся скобки сразу, либо в начале формулы или после НЕ ЧИСЛА (тогда часть отрицательного числа) иначе он просто операция. (А для установки отрицательного числа, накопившейся результат в q умножаем на мнимую единицу, которая всегда равна 1 кроме данного случая) 
								Znaki[Z]=R[i]; Prioritet[Z]=1+sk; Z++; mnI=1;
						   }else{mnI=-1;} break;
				case '*' : Znaki[Z]=R[i]; Prioritet[Z]=2+sk; mnI=1; Z++; break;
				case '/' : Znaki[Z]=R[i]; Prioritet[Z]=2+sk; mnI=1; Z++; break;
				case '(' : sk+=10; break;   // <- при встрече с открывающейся скобкой повышаем степень скобки
				case ')' : sk-=10; break;   // <- при встрече с закрывающейся скобкой понижаем степень скобки
			}
		}
	}
	//---решение   // <- комментарий
	while(C>1){   // <- цикл, говорящий "пока в формуле не останется одно значение"
		q=0;   // <- берем любую переменную и однуляем ее.
		for(int i=0; i<Z; i++){ if(Prioritet[i]>q){q=Prioritet[i]; sk=i;} }   // <- находим индекс, на котором находится операция с наивысшим приоритетом (тупо поиск максимального числа в массиве "Приоритет")
		if(Znaki[sk]=='+'){ allcifrs[sk]+=allcifrs[sk+1]; }   // <- выполняем данные операции
		if(Znaki[sk]=='-'){ allcifrs[sk]-=allcifrs[sk+1]; }   // <- выполняем данные операции
		if(Znaki[sk]=='*'){ allcifrs[sk]*=allcifrs[sk+1]; }   // <- выполняем данные операции
		if(Znaki[sk]=='/'){   // <- выполняем данные операции...
			if(allcifrs[sk+1]==0){   // <- ...но если вдруг делителем является 0...
				cout<<"ВНИМАНИЕ! деление на 0"<<endl; 
				system("pause");
				return 0;   // <- ... программа нас благословит
			}
			allcifrs[sk]/=allcifrs[sk+1];
		}
		for(int i=(sk+1); i<C-1; allcifrs[i]=allcifrs[i+1], i++);   // <- ... удаляем отработанную цифру, с которой мы провели операцию
		C--;
		for(int i=sk; i<Z-1; Prioritet[i]=Prioritet[i+1], i++);   // <- ... удаляем отработанную операцию
		for(int i=sk; i<Z-1; Znaki[i]=Znaki[i+1], i++);   // <- ... удаляем отработанный приоритет
		Z--;
	}
	return allcifrs[0];   // <- ... все результаты постепенно стянулись на 0-вую позицию и его мы возвращаем, как результат
}

int main(array<System::String ^> ^args) {
	setlocale(LC_ALL, "rus");
	char Formula[]={"2*(0+7)"};
	int Otvet=Parse(Formula,(sizeof(Formula)/sizeof(char)-1));
	cout<<"ФОРМУЛА : "<<Formula<<endl<<"ОТВЕТ : "<<Otvet<<endl;
	system("pause");
    return 0;
}